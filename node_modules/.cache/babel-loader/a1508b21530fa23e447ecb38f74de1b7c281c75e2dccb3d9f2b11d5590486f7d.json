{"ast":null,"code":"/**\n * Module dependencies.\n */\n\nconst JSONBigInt = require('json-bigint');\nconst RpcError = require('./errors/rpc-error');\nconst _ = require('lodash');\n\n/**\n * JSONBigInt parser.\n */\n\nconst {\n  parse\n} = JSONBigInt({\n  storeAsString: true,\n  strict: true\n}); // eslint-disable-line new-cap\n\n/**\n * Get RPC response body result.\n */\n\nfunction getRpcResult(body) {\n  let {\n    headers = false,\n    response\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (body.error !== null) {\n    throw new RpcError(_.get(body, 'error.code', -32603), _.get(body, 'error.message', 'An error occurred while processing the RPC call to bitcoind'));\n  }\n\n  // Defensive measure. This should not happen on a RPC call.\n  if (!_.has(body, 'result')) {\n    throw new RpcError(-32700, 'Missing `result` on the RPC call result');\n  }\n  if (headers) {\n    return [body.result, response.headers];\n  }\n  return body.result;\n}\n\n/**\n * Export Parser class.\n */\n\nmodule.exports = class Parser {\n  constructor() {\n    let {\n      headers\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.headers = headers;\n  }\n\n  /**\n   * Parse rpc response.\n   */\n\n  rpc(response) {\n    // The RPC api returns a `text/html; charset=ISO-8859-1` encoded response with an empty string as the body\n    // when an error occurs.\n    if (typeof response.body === 'string' && response.headers['content-type'] !== 'application/json' && response.statusCode !== 200) {\n      throw new RpcError(response.statusCode, response.statusMessage, {\n        body: response.body\n      });\n    }\n\n    // Parsing the body with custom parser to support BigNumbers.\n    const body = parse(response.body);\n    if (!Array.isArray(body)) {\n      return getRpcResult(body, {\n        headers: this.headers,\n        response\n      });\n    }\n\n    // Batch response parsing where each response may or may not be successful.\n    const batch = body.map(response => {\n      try {\n        return getRpcResult(response, {\n          headers: false,\n          response\n        });\n      } catch (e) {\n        return e;\n      }\n    });\n    if (this.headers) {\n      return [batch, response.headers];\n    }\n    return batch;\n  }\n  rest(extension, response) {\n    // The REST api returns a `text/plain` encoded response with the error line and the control\n    // characters \\r\\n. For readability and debuggability, the error message is set to this content.\n    // When requesting a binary response, the body will be returned as a Buffer representation of\n    // this error string.\n    if (response.headers['content-type'] !== 'application/json' && response.statusCode !== 200) {\n      if (response.body instanceof Buffer) {\n        response.body = response.body.toString('utf-8');\n      }\n      throw new RpcError(response.statusCode, response.body.replace('\\r\\n', ''), {\n        body: response.body\n      });\n    }\n\n    // Parsing the body with custom parser to support BigNumbers.\n    if (extension === 'json') {\n      response.body = parse(response.body);\n    }\n    if (this.headers) {\n      return [response.body, response.headers];\n    }\n    return response.body;\n  }\n};","map":{"version":3,"names":["JSONBigInt","require","RpcError","_","parse","storeAsString","strict","getRpcResult","body","headers","response","error","get","has","result","module","exports","Parser","constructor","rpc","statusCode","statusMessage","Array","isArray","batch","map","e","rest","extension","Buffer","toString","replace"],"sources":["/Users/petarjukic/Documents/Kriptovalute/Projekt/BlockExplorer/block_explorer/node_modules/bitcoin-core/src/parser.js"],"sourcesContent":["\n/**\n * Module dependencies.\n */\n\nconst JSONBigInt = require('json-bigint');\nconst RpcError = require('./errors/rpc-error');\nconst _ = require('lodash');\n\n/**\n * JSONBigInt parser.\n */\n\nconst { parse } = JSONBigInt({ storeAsString: true, strict: true }); // eslint-disable-line new-cap\n\n/**\n * Get RPC response body result.\n */\n\nfunction getRpcResult(body, { headers = false, response } = {}) {\n  if (body.error !== null) {\n    throw new RpcError(\n      _.get(body, 'error.code', -32603),\n      _.get(body, 'error.message', 'An error occurred while processing the RPC call to bitcoind')\n    );\n  }\n\n  // Defensive measure. This should not happen on a RPC call.\n  if (!_.has(body, 'result')) {\n    throw new RpcError(-32700, 'Missing `result` on the RPC call result');\n  }\n\n  if (headers) {\n    return [body.result, response.headers];\n  }\n\n  return body.result;\n}\n\n/**\n * Export Parser class.\n */\n\nmodule.exports = class Parser {\n  constructor({ headers } = {}) {\n    this.headers = headers;\n  }\n\n  /**\n   * Parse rpc response.\n   */\n\n  rpc(response) {\n    // The RPC api returns a `text/html; charset=ISO-8859-1` encoded response with an empty string as the body\n    // when an error occurs.\n    if (typeof response.body === 'string' && response.headers['content-type'] !== 'application/json' && response.statusCode !== 200) {\n      throw new RpcError(response.statusCode, response.statusMessage, { body: response.body });\n    }\n\n    // Parsing the body with custom parser to support BigNumbers.\n    const body = parse(response.body);\n\n    if (!Array.isArray(body)) {\n      return getRpcResult(body, { headers: this.headers, response });\n    }\n\n    // Batch response parsing where each response may or may not be successful.\n    const batch = body.map(response => {\n      try {\n        return getRpcResult(response, { headers: false, response });\n      } catch (e) {\n        return e;\n      }\n    });\n\n    if (this.headers) {\n      return [batch, response.headers];\n    }\n\n    return batch;\n  }\n\n  rest(extension, response) {\n    // The REST api returns a `text/plain` encoded response with the error line and the control\n    // characters \\r\\n. For readability and debuggability, the error message is set to this content.\n    // When requesting a binary response, the body will be returned as a Buffer representation of\n    // this error string.\n    if (response.headers['content-type'] !== 'application/json' && response.statusCode !== 200) {\n      if (response.body instanceof Buffer) {\n        response.body = response.body.toString('utf-8');\n      }\n\n      throw new RpcError(response.statusCode, response.body.replace('\\r\\n', ''), { body: response.body });\n    }\n\n    // Parsing the body with custom parser to support BigNumbers.\n    if (extension === 'json') {\n      response.body = parse(response.body);\n    }\n\n    if (this.headers) {\n      return [response.body, response.headers];\n    }\n\n    return response.body;\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}